/**
 * Tree-generating parser for Quant.
 *
 * Run with CUP to generate sym.java
 * (Needed to run scanner generated by
 * JFlex + lexer.jflex.)
 * --Aubrey
 */

import java_cup.runtime.*;
import java.util.ArrayList;
import java.util.HashMap;

action code {:
    public SymbolRecord symrecord = new SymbolRecord();
    public void identClassError(String identifier, int expected, int found){
        System.out.println("It looks like you're using '"+identifier+"'as a "+
            SymbolRecord.CLASSES[expected]+", but it's a "+
            SymbolRecord.CLASSES[found]+"!");
        System.exit(0);
    }
    public void notDefinedError(String identifier){
        System.out.println("Wait a second!  What's a '"+identifier+"'?");
        System.exit(0);
    }
    public void typeMismatch(String type, String field, String expected, String found){
        if(expected.equals("String")){ expected = "string"; }
        if(expected.equals("NUMVAL")){ expected = "quantity"; }
        if(found.equals("String")){ found = "string"; }
        if(found.equals("NUMVAL")){ found = "quantity"; }
        System.out.println("Hold on a minute!  You're using a "+type+"'s "+field+" as a "+
                           found+", but you said before that it was a "+expected+"!");
        System.exit(0);
    }
    public void typeMembError(String ident, String memb){
        System.out.println("Woops!  "+ident+" doesn't have a '"+memb+"'!");
        System.exit(0);
    }
    public void typeDefError(String type, String stype, int err){
        if(err == SymbolRecord.TYPE_DEFINED)
            System.out.println("Woops!  You've said what a '"+type+"' is twice!");
        else if(err == SymbolRecord.SUPERTYPE_UNDEFINED)
            System.out.println("Wait a second!  You said a '"+type+"' was a '"+stype+"'...\n"+
                               "What's a '"+stype+"'?");
        else
            System.out.println("Woops!  It looks like you haven't said what a '"+type+"' is!");
        System.exit(0);
    }
    
:}

parser code {:
:}

/*
 * Symbol definitions`
 */
terminal PRINT;
terminal A; 
terminal IS_A;
terminal IS, ARE;
terminal ITS;
terminal SET;
terminal TO, THAN, NOT; 
terminal IF, THEN, ELSE, WHILE;
terminal LESS_THAN, GREATER_THAN, EQUAL_TO, NEQUAL_TO;
terminal AND, OR;
terminal THERE; 
terminal IN;
terminal FOR;
terminal EVERY; 
terminal HAS;
terminal WITH;
terminal HAVING; 
terminal APO_S;
terminal TOTAL;
terminal OF;
terminal WHAT;
terminal IS_C;

terminal String IDENTIFIER;
terminal String STRING_LITERAL;
terminal Integer INTEGER_LITERAL;
terminal Double RATIONAL_LITERAL;

terminal LPAREN, RPAREN;
terminal PLUS, MINUS, TIMES, DIVIDE;
terminal PERIOD, COLON, SEMICOLON, QMARK;
terminal CONNECTOR;
terminal INVALID;

/*
 * non-terminals
 */
non terminal Node line_block;
non terminal Node line;
non terminal Node statement;
non terminal Node stmt_sequence;
non terminal Node optv_statement;
non terminal Node asmt_statement;
non terminal Node line_terminator;
non terminal Node operative_kwd;
non terminal Node value;
non terminal Node quantity;
non terminal Node number;
non terminal Node unit;
non terminal Node expression;
non terminal Node field;
non terminal Node cond_block;
non terminal Node if_then_else;
non terminal Node while;
non terminal Node bool_seq;
non terminal Node bool_exp;
non terminal conjunctive;
non terminal Node rate_dec; 
non terminal Node type_dec; 
non terminal Node colon; 
non terminal Node type_sig;
non terminal Node type_ref; 
non terminal Node mem_type_chain;
non terminal Node mem_type;
non terminal Node mem_ref; 
non terminal Node ident_chain;   
non terminal Node obj_func_dec;
non terminal Node field_expr;
non terminal Node agg_expr;
non terminal Node is_cond;
non terminal ComplexIdentifier complex_id;

precedence left LESS_THAN, GREATER_THAN, EQUAL_TO, NEQUAL_TO;
precedence left AND, OR;
precedence left PLUS, MINUS;
precedence left TIMES, DIVIDE;
precedence left ELSE;

line_block	::= line_block:lb line:ln
		    {: lb.addChild(ln); RESULT = lb; :}
		    |
		    line:ln
		    {: LineBlock lb = new LineBlock(ln); 
                       lb.symrecord = symrecord;
                       RESULT = lb;
                    :}
		    ;

line		::= statement:stmt line_terminator:lt
		    {: RESULT = new Line(stmt, lt); :}
                    |
		    rate_dec:rd line_terminator:lt
	 	    {: RESULT = new Line(rd,lt); :}
		    |
                    obj_func_dec:od line_terminator:lt
                    {: RESULT = new Line(od,lt); :}
                    |
                    type_dec:td line_terminator:lt
                    {: RESULT = new Line(td,lt); :}
                    |
                    is_cond:ic
		    {: RESULT = ic; :}
                    |
                    cond_block:cb
		    {: RESULT = cb; :}
                    ;

rate_dec	::= THERE IS number:n unit:u IN number:n2 unit:u2
		    {: RESULT = new RateDeclaration(n,u,n2,u2); :}
		    |
		    THERE ARE number:n unit:u IN number:n2 unit:u2
		    {: RESULT = new RateDeclaration(n,u,n2,u2); :}
		    |
		    THERE IS number:n unit:u FOR EVERY number:n2 unit:u2
		    {: RESULT = new RateDeclaration(n,u,n2,u2); :}
		    |
		    THERE ARE number:n unit:u FOR EVERY number:n2 unit:u2
		    {: RESULT = new RateDeclaration(n,u,n2,u2); :}
		    ;

type_dec	::= type_sig:sig COLON mem_type_chain:mem_chain    
		    {: 
                       TypeDec dec = new TypeDec(sig, null, symrecord);
                       String type = ((TypeRef) ((TypeSignature) sig).typeRef).getType();
                       DefinedType oType = symrecord.getTypeObj(type);
                       ArrayList<Node> mTypes = ((MemTypeChain) mem_chain).memTypes;
                       for(int i = 0; i < mTypes.size(); i++){
                           MemberType mt = (MemberType) mTypes.get(i);
                           oType.setValue(mt.identifier,mt.type,mt.val);
                       }
                       RESULT = dec;
                    :}
		    |
		    type_sig:sig
		    {: RESULT = new TypeDec(sig, null, symrecord); :}
		    ;

agg_expr	::= TOTAL complex_id:id OF quantity:qnt
		    {:
                       Quantity q = (Quantity) qnt;
                       Unit qunit = (Unit) q.unit;
                       Number qnumber = (Number) q.number;
                       if(q.unit == null){ System.out.println("Woops! You can't total the "+
                                              id.id.replace("_"," ") +
                                              " of a number!"); System.exit(0); }
                       DefinedType type = symrecord.getTypeObj(qunit.unit);
                       if(symrecord.getClass(qunit.unit)!=SymbolRecord.TYPE_CLASS || type == null){
                           System.out.println("Woops!  You can't total the "+id.id.replace("_"," ")+
                                                " of a unit!");
                           System.exit(0);
                       }
                       if(!type.funcs.contains(id.id) && !type.fields.contains(id.id)){
                           System.out.println("Wait a minute... You didn't say that a "+qunit.unit+
                                               " has " + id.natural() + "!"); System.exit(0);
                       }
                       boolean isFunc = type.funcs.contains(id.id);
                       RESULT = new Aggregator(qunit.unit, id.id, qnumber.iVal, symrecord, isFunc);
		    :}
		    |
                    TOTAL complex_id:id OF field:f 
                    {:
                        if(!symrecord.getType(((Variable) f).getName()).equals("NUMVAL")){
                            System.out.println("You can't find a total on "+((Variable) f).getName());
                            System.exit(0);
                        }
                       RESULT = new Aggregator(((Variable) f),symrecord,id.id);
		    :}
		    ;

obj_func_dec	::= type_ref:ref APO_S complex_id:id IS field_expr:expr
		    {:
                       TypeRef tref = (TypeRef) ref;
                       FieldExpression fexpr = (FieldExpression) expr;

                       String func = id.id;
                       ArrayList<String> parts = fexpr.getParts();
                       symrecord.getTypeObj(tref.getType()).addFunc(func,parts);

		       RESULT = new BlankNode();
                    :}
                    ;

type_sig	::= type_ref:ref HAS ident_chain:ident_chain
		    {: 
                       String type = ((TypeRef) ref).getType();
                       int err = symrecord.defineType(type,null);
                       if(err != 0)
                           typeDefError(type,null,err);
                       symrecord.addTypeFields(type,((IdentifierChain) ident_chain).getIdentifiers());
                       RESULT = new TypeSignature(ref,ident_chain,symrecord); 
                    :}
		    |
		    type_ref:ref WITH ident_chain:ident_chain
                    {:
                       String type = ((TypeRef) ref).getType();
                       int err = symrecord.defineType(type,null);
                       if(err != 0)
                           typeDefError(type,null,err);
                       symrecord.addTypeFields(type,((IdentifierChain) ident_chain).getIdentifiers());
                       RESULT = new TypeSignature(ref,ident_chain,symrecord); 
		    :}
		    |
		    type_ref:ref HAVING ident_chain:ident_chain
		    {:
                       String type = ((TypeRef) ref).getType();
                       int err = symrecord.defineType(type,null);
                       if(err != 0)
                           typeDefError(type,null,err);
                       symrecord.addTypeFields(type,((IdentifierChain) ident_chain).getIdentifiers());
                       RESULT = new TypeSignature(ref,ident_chain,symrecord); 
 
                    :}
		    |
                    type_ref:ref IS type_ref:ref2
                    {:
                        String nType = ((TypeRef) ref).getType();
                        String sType = ((TypeRef) ref2).getType();
                        int err = symrecord.defineType(nType,sType);
                        if(err != 0)
                           typeDefError(nType,sType,err);
                        //symrecord.addTypeFields(ntype,((IdentifierChain) ident_chain).getIdentifiers());
                        TypeSignature ts = new TypeSignature(ref,ref2,null,symrecord);
                        RESULT = ts;
                    :}
                    |
		    type_ref:ref IS type_ref:ref2 WITH ident_chain:ident_chain
		    {:
                        String nType = ((TypeRef) ref).getType();
                        String sType = ((TypeRef) ref2).getType();
                        int err = symrecord.defineType(nType,sType);
                        if(err != 0)
                           typeDefError(nType,sType,err);
                        symrecord.addTypeFields(nType,((IdentifierChain) ident_chain).getIdentifiers());
                        TypeSignature ts = new TypeSignature(ref,ref2,null,symrecord);
                        RESULT = ts;
                    :}
		    |
		    type_ref:ref IS type_ref:ref2 HAVING ident_chain:ident_chain
		    {:
                        String nType = ((TypeRef) ref).getType();
                        String sType = ((TypeRef) ref2).getType();
                        int err = symrecord.defineType(nType,sType);
                        if(err != 0)
                           typeDefError(nType,sType,err);
                        symrecord.addTypeFields(nType,((IdentifierChain) ident_chain).getIdentifiers());
                        TypeSignature ts = new TypeSignature(ref,ref2,null,symrecord);
                        RESULT = ts;
 
                    :}
		    ; 

mem_type_chain  ::= mem_type_chain:mem_type AND mem_type:mem_type1
		    {:
                       mem_type.addChild(mem_type1);
                       RESULT = mem_type; 
                    :}
		    |
		    mem_type_chain:mem_type_chain CONNECTOR mem_type:mem
		    {:
                       mem_type_chain.addChild(mem);
                       RESULT = mem_type_chain; 
                    :}
		    |
		    mem_type_chain:mem_type_chain CONNECTOR AND mem_type:mem
		    {:
                       mem_type_chain.addChild(mem);
                       RESULT = mem_type_chain; 
                    :}
		    |
		    mem_type:mem
		    {: RESULT = new MemTypeChain(mem); :}
		    ;

mem_type	::= complex_id:id IS type_ref:ref
		    {:
                        String type = ((TypeRef) ref).getType();
                        if(!symrecord.typeIsDefined(type)){
                            typeDefError(id.natural(),null,10);
                        }
                        RESULT = new MemberType(id.id, type, "" , symrecord);
                    :}
		    |
		    complex_id:id IS expression:expr
		    {:
                        if(expr.getSemanticRepresentation().equals("STRING")){
                            RESULT = new MemberType(id.id,"String", expr.translate()[1], symrecord);
                        } else{
                            String trans = expr.translate()[1];
                            if(expr.getSemanticRepresentation().equals(""))
                            	RESULT = new MemberType(id.id,"NUMVAL",trans,symrecord);
                            else{
                                String t = expr.getSemanticRepresentation();
                                RESULT = new MemberType(id.id,expr.getSemanticRepresentation(),
                                                trans,symrecord);
                            }
                        } 
                    :}
                    |
		    ITS complex_id:id IS type_ref:ref
		    {:
                        String type = ((TypeRef) ref).getType();
                        if(!symrecord.typeIsDefined(type)){
                            typeDefError(id.natural(),null,10);
                        }
                        RESULT = new MemberType(id.id, type, "" , symrecord);
                    :}
		    |
		    ITS complex_id:id IS expression:expr
		    {:
                        if(expr.getSemanticRepresentation().equals("STRING")){
                            RESULT = new MemberType(id.id,"String", expr.translate()[1], symrecord);
                        } else{
                            String trans = expr.translate()[1];
                            if(expr.getSemanticRepresentation().equals(""))
                            	RESULT = new MemberType(id.id,"NUMVAL",trans,symrecord);
                            else{
                                String t = expr.getSemanticRepresentation();
                                RESULT = new MemberType(id.id,expr.getSemanticRepresentation(),
                                                trans,symrecord);
                            }
                        } 
                    :}

		    ;

type_ref	::= A complex_id:id
		    {: int i = symrecord.setClass(id.id, SymbolRecord.TYPE_CLASS);
                       if(i == SymbolRecord.UNIT_CLASS){ 
                           symrecord.classRecord.put(id.id,SymbolRecord.TYPE_CLASS);
                       }
                       else if(i != 0){ identClassError(id.natural(), SymbolRecord.TYPE_CLASS, i); }
                       RESULT = new TypeRef(id.id,symrecord); 
                    :}
		    ;

ident_chain  	::= complex_id:id
		    {: RESULT = new IdentifierChain(id.id); :}
		    |
		    ident_chain:ident2 AND complex_id:id
		    {: ((IdentifierChain) ident2).addIdentifier(id.id); 
                       RESULT = ident2;
                    :}
		    |
		    ident_chain:ident4 CONNECTOR complex_id:id
		    {: ((IdentifierChain) ident4).addIdentifier(id.id); 
                       RESULT = ident4;
                    :} 
		    |
		    ident_chain:ident6 CONNECTOR AND complex_id:id 
		    {: ((IdentifierChain) ident6).addIdentifier(id.id); 
                       RESULT = ident6;
                    :}
		    |
		    A complex_id:id
		    {: RESULT = new IdentifierChain(id.id); :}
		    |
		    ident_chain:ident2 AND A complex_id:id
		    {: ((IdentifierChain) ident2).addIdentifier(id.id); 
                       RESULT = ident2;
                    :}
		    |
		    ident_chain:ident4 CONNECTOR A complex_id:id
		    {: ((IdentifierChain) ident4).addIdentifier(id.id); 
                       RESULT = ident4;
                    :} 
		    |
		    ident_chain:ident6 CONNECTOR AND A complex_id:id
		    {: ((IdentifierChain) ident6).addIdentifier(id.id); 
                       RESULT = ident6;
                    :}

		    ; 

statement	::= optv_statement:ostmt
		    {: RESULT = new Statement(ostmt); :}
		    |
		    asmt_statement:astmt
		    {: RESULT = new Statement(astmt); :}
		    ;

stmt_sequence	::= statement:s
		    {: RESULT = new StatementSequence(s); :}
		    |
		    cond_block:cb
		    {: RESULT = new StatementSequence(cb); :}
		    |
		    stmt_sequence:seq CONNECTOR statement:stmt
		    {: seq.addChild(stmt);
		       RESULT = seq;
		    :}
		    |
		    stmt_sequence:seq CONNECTOR AND statement:stmt
		    {: seq.addChild(stmt);
		       RESULT = seq;
		    :}
		    |
		    cond_block:cb statement:s
		    {: StatementSequence seq = new StatementSequence(cb);
		       seq.addChild(s);
		       RESULT = seq;
		    :}
		    |
		    cond_block:cb cond_block:cb2
		    {: StatementSequence seq = new StatementSequence(cb);
		       seq.addChild(cb2);
		       RESULT = seq;
		    :}
		    |

		    stmt_sequence:seq AND statement:stmt
		    {: seq.addChild(stmt);
		       RESULT = seq;
		    :}

		    ;

cond_block	::= if_then_else:i
		    {: RESULT = i; :}
		    |
		    while:w
		    {: RESULT = w; :}
                    
		    ;

is_cond		::= IS_C bool_exp:b QMARK
		    {: RESULT = new IsCondition(b); :}
		    ;

if_then_else	::= IF bool_seq:cond CONNECTOR THEN stmt_sequence:t_seq 
		        conjunctive
		    {: RESULT = new IfElseBlock(cond,t_seq,null); :}
		    |
		    IF bool_seq:cond CONNECTOR THEN stmt_sequence:t_seq
		        conjunctive ELSE CONNECTOR stmt_sequence:f_seq 
		            conjunctive
		    {: RESULT = new IfElseBlock(cond,t_seq,f_seq); :}
		    |
		    
                    IF bool_seq:cond CONNECTOR stmt_sequence:t_seq conjunctive
		    {: RESULT = new IfElseBlock(cond,t_seq,null); :}
		    |
		    IF bool_seq:cond CONNECTOR stmt_sequence:t_seq
		        conjunctive ELSE CONNECTOR stmt_sequence:f_seq 
		            conjunctive
		    {: RESULT = new IfElseBlock(cond,t_seq,f_seq); :}

		    ;

conjunctive	::= SEMICOLON
		    |
		    PERIOD
		    ;

while		::= WHILE bool_seq:cond CONNECTOR stmt_sequence:t_seq PERIOD
		    {: RESULT = new WhileBlock(cond, t_seq); :}
		    ;

bool_seq	::= bool_exp:exp
		    {:  System.out.println("bool seq found");
                        RESULT = new BooleanSequence(exp,null,-1); 
                    :}
		    |
		    bool_seq:l AND bool_seq:r
		    {: RESULT = new BooleanSequence(l,r,Node.SEM_AND);
		    :}
		    |
		    bool_seq:l OR bool_seq:r
		    {: RESULT = new BooleanSequence(l,r,Node.SEM_OR);
		    :}
		    |
		    LPAREN bool_seq:s RPAREN
		    {: RESULT = s; :}
		    ;

bool_exp	::= expression:l LESS_THAN expression:r
		    {: RESULT = new BooleanExpression(l,r, Node.SEM_LESS_THAN);
                       System.out.println("boolexp found");
		    :}
		    |
		    expression:l GREATER_THAN expression:r
		    {: RESULT = new BooleanExpression(l,r, 
                           Node.SEM_GREATER_THAN);
		    :}
		    |
		    expression:l EQUAL_TO expression:r
		    {: RESULT = new BooleanExpression(l,r,
		           Node.SEM_EQUAL_TO);
		    :}
		    |
		    expression:l IS expression:r
		    {: RESULT = new BooleanExpression(l,r,
		           Node.SEM_EQUAL_TO);
		    :}
		    |

		    expression:l NEQUAL_TO expression:r
		    {: RESULT = new BooleanExpression(l,r,
		           Node.SEM_NEQUAL_TO);
		    :}
		    |
                    expression:l IS LESS_THAN THAN expression:r
		    {: RESULT = new BooleanExpression(l,r, Node.SEM_LESS_THAN);
                       System.out.println("boolexp found");
		    :}
		    |
		    expression:l IS GREATER_THAN THAN expression:r
		    {: RESULT = new BooleanExpression(l,r, 
                           Node.SEM_GREATER_THAN);
		    :}
		    |
		    expression:l IS EQUAL_TO TO expression:r
		    {: RESULT = new BooleanExpression(l,r,
		           Node.SEM_EQUAL_TO);
		    :}
		    |
		    expression:l IS NOT EQUAL_TO TO expression:r
		    {: RESULT = new BooleanExpression(l,r,
		           Node.SEM_NEQUAL_TO);
		    :}
		    |
                    expression:l LESS_THAN THAN expression:r
		    {: RESULT = new BooleanExpression(l,r, Node.SEM_LESS_THAN);
                       System.out.println("boolexp found");
		    :}
		    |
		    expression:l GREATER_THAN THAN expression:r
		    {: RESULT = new BooleanExpression(l,r, 
                           Node.SEM_GREATER_THAN);
		    :}
		    |
		    expression:l EQUAL_TO TO expression:r
		    {: RESULT = new BooleanExpression(l,r,
		           Node.SEM_EQUAL_TO);
		    :}
		    |
		    expression:l NOT EQUAL_TO TO expression:r
		    {: RESULT = new BooleanExpression(l,r,
		           Node.SEM_NEQUAL_TO);
		    :}
	            ;

asmt_statement	::= field:f IS expression:v
		    {: 
		       if(v.getSemanticRepresentation().equals("STRING"))
		           ((Variable) f).setType(SymbolRecord.STRING_TYPE);
		       else
		           ((Variable) f).setType(v.getSemanticRepresentation());
                       String left, right;
                       Variable var = (Variable) f;
                       String assType = v.getSemanticRepresentation().equals("STRING") ? "String" : 
                           v.getSemanticRepresentation();
                       if(var.name.indexOf('.')>=0){
                           left = var.name.substring(0, var.name.indexOf('.'));
                           right = var.name.substring(var.name.indexOf('.')+1);
                           while(right.indexOf('.') > 0){
                               left = right.substring(0,right.indexOf('.'));
                               right = right.substring(right.indexOf('.')+1);
                           }
                           // Infer type
                           String type = symrecord.getType(left);
                           DefinedType typeObj = symrecord.getTypeObj(type);
                           if(typeObj!=null&&symrecord.getType(type+"."+right).equals("Object")){ 
                               typeObj.setType(right, assType); 
                           } else if(!symrecord.getType(type+"."+right).equals(assType)){
                               typeMismatch(type, right, symrecord.getType(type+"."+right), assType);
                           }
                       }
                       if(v.getClass().getName().equals("Value")){
                           Value vv = (Value) v;
                         
                           if(vv.wrappedValue.getClass().getName().equals("Quantity")){
                               Quantity vq = (Quantity) vv.wrappedValue;
                               if(vq.unit != null)
                                   symrecord.unitMap.put(((Variable) f).getName(),((Unit)vq.unit).unit);
                           }
                       }
		       RESULT = new AssignmentStatement(f,v,
		                        Node.ASSMNT_MODE);
		    :}
		    |
		    SET field:f TO expression:v
		    {: if(v.getSemanticRepresentation().equals("STRING"))
		           ((Variable) f).setType(SymbolRecord.STRING_TYPE);
		       else
		           ((Variable) f).setType(v.getSemanticRepresentation());
                       String left, right;
                       Variable var = (Variable) f;
                       String assType = v.getSemanticRepresentation().equals("STRING") ? "String" : 
                           v.getSemanticRepresentation();
                       if(var.name.indexOf('.')>=0){
                           left = var.name.substring(0, var.name.indexOf('.'));
                           right = var.name.substring(var.name.indexOf('.')+1);
                           while(right.indexOf('.') > 0){
                               left = right.substring(0,right.indexOf('.'));
                               right = right.substring(right.indexOf('.')+1);
                           }
                           // Infer type
                           String type = symrecord.getType(left);
                           System.out.println(type);
                           DefinedType typeObj = symrecord.getTypeObj(type);
                           if(typeObj!=null&&symrecord.getType(type+"."+right).equals("Object")){ 
                               typeObj.setType(right, assType); 
                           } else if(!symrecord.getType(type+"."+right).equals(assType)){
                               typeMismatch(type, right, symrecord.getType(type+"."+right), assType);
                           }
                       }
                       if(v.getClass().getName().equals("Value")){
                           Value vv = (Value) v;
                         
                           if(vv.wrappedValue.getClass().getName().equals("Quantity")){
                               Quantity vq = (Quantity) vv.wrappedValue;
                               symrecord.unitMap.put(((Variable) f).getName(),((Unit)vq.unit).unit);
                           }
                       }

		       RESULT = new AssignmentStatement(f,v,
		                        Node.ASSMNT_MODE);
		    :}
                    |
                    field:f IS type_ref:ref
		    {:
                        String type = ((TypeRef) ref).getType();
                        if(!symrecord.typeIsDefined(type))
                            typeDefError(type,"",10);
                        Variable var = (Variable) f;
                        String left, right;
                        String assType = type;
                        if(var.name.indexOf('.')>=0){
                           left = var.name.substring(0, var.name.indexOf('.'));
                           right = var.name.substring(var.name.indexOf('.')+1);
                           while(right.indexOf('.') > 0){
                               left = right.substring(0,right.indexOf('.'));
                               right = right.substring(right.indexOf('.')+1);
                           }
                           // Infer type
                           String rtype = symrecord.getType(left);
                           DefinedType typeObj = symrecord.getTypeObj(rtype);
                           DefinedType membType = 
                               symrecord.getTypeObj(symrecord.getType(rtype+"."+right));
                           DefinedType atO = symrecord.getTypeObj(assType);
                           if(typeObj!=null&&symrecord.getType(rtype+"."+right).equals("Object")){ 
                               typeObj.setType(right, assType); 
                           } else if(!symrecord.getType(rtype+"."+right).equals(assType) &&
                                   !atO.inheritsFrom(symrecord.getType(rtype+"."+right))){
                               typeMismatch(rtype, right, symrecord.getType(rtype+"."+right), assType);
                           } else{ typeObj.setType(right, assType); }

                        }
   
                        ((Variable) f).setType(type);
                        RESULT = new AssignmentStatement(f,ref,
                                        Node.ASSMNT_MODE); 
                    :}	
		    ;

optv_statement	::= operative_kwd:kwd expression:e
		    {: RESULT = new OperativeStatement(kwd, e); :}
                    |
		    WHAT IS expression:e
                    {: RESULT = new OperativeStatement(new OperativeKeyword(Node.SEM_PRINT_KWD), e); :}
		    ;

operative_kwd	::= PRINT
		    {: RESULT = new OperativeKeyword(Node.SEM_PRINT_KWD); :}
		    ;

field_expr	::= STRING_LITERAL:s
                    {:
                       RESULT = new FieldExpression(new StringConstant(s), null, -1);
                    :}
                    |
                    quantity:q
                    {:
                       RESULT = new FieldExpression(q,null,-1);
                    :}
                    |
                    complex_id:id
                    {:
                       RESULT = new FieldExpression(id.id);
                    :}
		    |
		    ITS complex_id:id
                    {:
                       RESULT = new FieldExpression(id.id);
		    :}
		    |
		    field_expr:l PLUS field_expr:r
		    {:
                       RESULT = new FieldExpression(l,r,Node.SEM_PLUS);
		    :}
		    |
		    field_expr:l MINUS field_expr:r
		    {:
                       RESULT = new FieldExpression(l,r,Node.SEM_MINUS);
		    :}
		    |
		    field_expr:l TIMES field_expr:r
		    {:
                       RESULT = new FieldExpression(l,r,Node.SEM_TIMES);
		    :}
		    |
		    field_expr:l DIVIDE field_expr:r
		    {:
                       RESULT = new FieldExpression(l,r,Node.SEM_DIVIDE);
		    :}
                    |
                    LPAREN field_expr:e RPAREN
                    {:
                       RESULT = e;
                    :}
		    ;

expression	::= expression:l PLUS expression:r
		    {: RESULT = new Expression(l,r, Node.SEM_PLUS); :}
		    |
		    expression:l MINUS expression:r
		    {: RESULT = new Expression(l,r, Node.SEM_MINUS); :}
    		    |
		    expression:l TIMES expression:r
		    {: RESULT = new Expression(l,r, Node.SEM_TIMES); :}
		    |
		    expression:l DIVIDE expression:r
		    {: RESULT = new Expression(l,r, Node.SEM_DIVIDE); :}
		    |
                    agg_expr:a
		    {: RESULT = a; :}
		    |
		    value:v
		    {: RESULT = v; :}
		    |
		    LPAREN expression:v RPAREN
		    {: RESULT = v; :}
                    ;

value		::= STRING_LITERAL:s
		    {: RESULT = new StringConstant(s); :}
		    |
		    quantity:q
		    {: RESULT = new Value(q); :}
		    |
		    field:f
		    {: if(symrecord.getType(((Variable) f).getName())==null)
		           notDefinedError(((Variable) f).getName());
		       RESULT = f;
		    :}
		    ;

quantity	::= number:num unit:u
		    {: 
                        
                        RESULT = new Quantity(num, u);                   
                    :}
                    |
		    number:num
		    {: RESULT = new Quantity(num, null); :}
		    ;

number		::= INTEGER_LITERAL:num
		    {: RESULT = new Number(num); :}
		    |
		    RATIONAL_LITERAL:num
		    {: RESULT = new Number(num); :}
		    ;

unit		::= complex_id:id
		    {: 
                       // If it's an object type...
                       String[] alt = new String[5];
                       alt[0] = id.id; alt[1] = id.id+"s";
                       alt[2] = id.id+"es"; alt[3] = id.id.length()>2 ? 
                                                      id.id.substring(0,id.id.length()-1) : id.id;
                       alt[4] = id.id.length() > 3 ?
                                  id.id.substring(0,id.id.length()-2) : id.id;
                       SymbolRecord sr = symrecord;
                       for(String s : alt){
                           if(sr.getClass(id.id) == 0 && (sr.getClass(s) != 0 || sr.getTypeObj(s) != null))
                               id.id = s;
                       }
                       int prevClass = 
			   symrecord.setClass(id.id, SymbolRecord.UNIT_CLASS);
                       if(prevClass != 0 && prevClass != SymbolRecord.TYPE_CLASS)
		           identClassError(id.natural(), SymbolRecord.UNIT_CLASS, 
	 	               prevClass);
		       RESULT = new Unit(id.id);
                     :}
		     ;

field		::= complex_id:id
		    {:
		       int prevClass = 
		        symrecord.setClass(id.id, SymbolRecord.VARIABLE_CLASS);
		       if(prevClass != 0)
		           identClassError(id.natural(), SymbolRecord.VARIABLE_CLASS,
		               prevClass);
		       RESULT = new Variable(id.id, symrecord);
		    :}
		    |
                    mem_ref:mem
		    {:
                       Variable v = new Variable( ((MemberRef) mem).getName(), symrecord );
          
                       v.trDef = ((MemberRef) mem).funcRef ? ((MemberRef) mem).translate()[1] : "";
                       v.ignoreDecl = 1;
                       RESULT = v;
                    :}
		    ;

mem_ref		::= field:ident1 APO_S complex_id:id
		    {:
                        String type = symrecord.getType(((Variable) ident1).getName());
                        String mType = "";
                        boolean isFunc = false;
                        DefinedType typeObj = symrecord.getTypeObj(type);
                        if(typeObj==null||(!typeObj.fields.contains(id.id) && 
                                !typeObj.funcs.contains(id.id)))
                            typeMembError(((Variable) ident1).getName(), id.natural());
                        else if(typeObj.funcs.contains(id.id)){
                            int index = typeObj.funcs.indexOf(id.id);
                            typeObj.popFunc(id.id);
                            mType = typeObj.funcTypes.get(index);
                            if(mType.equals("NONE")) mType = "STRING";
                            isFunc = true;
                        }
                        else
                            mType = typeObj.fieldTypes.get(typeObj.fields.indexOf(id.id));
                        
                        symrecord.setType(((Variable) ident1).getName()+"."+id.id, mType);
                        
                        MemberRef ref = new MemberRef(ident1, id.id, mType, symrecord);
                        ref.funcRef = isFunc;    
                        RESULT = ref;
                    :}
		    ;

line_terminator ::= PERIOD
		    {: RESULT = new Terminator(Node.IMP_TERM); :}
		    |
                    QMARK
		    {: RESULT = new Terminator(Node.IMP_TERM); :}
		    ;

complex_id	::= IDENTIFIER:i
		    {: ComplexIdentifier id = new ComplexIdentifier();
		       id.id = i;
                       RESULT = id;
		    :}
		    |
		    complex_id:c IDENTIFIER:i
		    {:
		       c.id+="_"+i;
		       RESULT = c;
		    :}
		    ;
