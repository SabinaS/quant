/**
 * Tree-generating parser for Quant.
 *
 * Run with CUP to generate sym.java
 * (Needed to run scanner generated by
 * JFlex + lexer.jflex.)
 * --Aubrey
 */

import java_cup.runtime.*;

action code {:
    public SymbolRecord symrecord = new SymbolRecord();
    public void identClassError(String identifier, int expected, int found){
        System.out.println("Error: '"+identifier+"' is used as a "+
            SymbolRecord.CLASSES[expected]+" but is a "+
            SymbolRecord.CLASSES[found]+".");
        System.exit(0);
    }
    public void notDefinedError(String identifier){
        System.out.println("Error: '"+identifier+"' is not defined.");
        System.exit(0);
    }
:}

parser code {:
:}

/*
 * Symbol definitions`
 */

terminal PRINT;
terminal IS_A;
terminal IS;
terminal SET;
terminal TO; 

terminal String IDENTIFIER;
terminal String STRING_LITERAL;
terminal Integer INTEGER_LITERAL;
terminal Double RATIONAL_LITERAL;

terminal LPAREN, RPAREN;
terminal PLUS, MINUS, TIMES, DIVIDE;
terminal PERIOD;
terminal INVALID;

/*
 * non-terminals
 */
non terminal Node line_block;
non terminal Node line;
non terminal Node statement;
non terminal Node optv_statement;
non terminal Node asmt_statement;
non terminal Node line_terminator;
non terminal Node operative_kwd;
non terminal Node value;
non terminal Node quantity;
non terminal Node number;
non terminal Node unit;
non terminal Node expression;
non terminal Node field;

precedence left PLUS, MINUS;
precedence left TIMES, DIVIDE;

line_block	::= line_block:lb line:ln
		    {: lb.addChild(ln); RESULT = lb; :}
		    |
		    line:ln
		    {: RESULT = new LineBlock(ln); :}
		    ;

line		::= statement:stmt line_terminator:lt
		    {: RESULT = new Line(stmt, lt); :}
                    ;		    

statement	::= optv_statement:ostmt
		    {: RESULT = new Statement(ostmt); :}
		    |
		    asmt_statement:astmt
		    {: RESULT = new Statement(astmt); :}
		    ;

asmt_statement	::= field:f IS expression:v
		    {: 
		       if(v.getSemanticRepresentation().equals("STRING"))
		           ((Variable) f).setType(SymbolRecord.STRING_TYPE);
		       else
		           ((Variable) f).setType(SymbolRecord.QUANTITY_TYPE);
		       RESULT = new AssignmentStatement(f,v,
		                        Node.ASSMNT_MODE);
		    :}
		    |
		    SET field:f TO value:v
		    {: if(v.getSemanticRepresentation().equals("STRING"))
		           ((Variable) f).setType(SymbolRecord.STRING_TYPE);
		       else
		           ((Variable) f).setType(SymbolRecord.QUANTITY_TYPE);
		       RESULT = new AssignmentStatement(f,v,
		                        Node.ASSMNT_MODE);
		    :}	
		    ;

optv_statement	::= operative_kwd:kwd expression:e
		    {: RESULT = new OperativeStatement(kwd, e); :}
		    ;

operative_kwd	::= PRINT
		    {: RESULT = new OperativeKeyword(Node.SEM_PRINT_KWD); :}
		    ;

expression	::= expression:l PLUS expression:r
		    {: RESULT = new Expression(l,r, Node.SEM_PLUS); :}
		    |
		    expression:l MINUS expression:r
		    {: RESULT = new Expression(l,r, Node.SEM_MINUS); :}
    		    |
		    expression:l TIMES expression:r
		    {: RESULT = new Expression(l,r, Node.SEM_TIMES); :}
		    |
		    expression:l DIVIDE expression:r
		    {: RESULT = new Expression(l,r, Node.SEM_DIVIDE); :}
		    |
		    value:v
		    {: RESULT = v; :}
		    |
		    LPAREN expression:v RPAREN
		    {: RESULT = v; :}
                    ;

value		::= STRING_LITERAL:s
		    {: RESULT = new StringConstant(s); :}
		    |
		    quantity:q
		    {: RESULT = new Value(q); :}
		    |
		    field:f
		    {: if(symrecord.getType(((Variable) f).getName())==null)
		           notDefinedError(((Variable) f).getName());
		       RESULT = f;
		    :}
		    ;

quantity	::= number:num unit:u
		    {: RESULT = new Quantity(num, u); :}
                    |
		    number:num
		    {: RESULT = new Quantity(num, null); :}
		    ;

number		::= INTEGER_LITERAL:num
		    {: RESULT = new Number(num); :}
		    |
		    RATIONAL_LITERAL:num
		    {: RESULT = new Number(num); :}
		    ;

unit		::= IDENTIFIER:ident
		    {: 
                       int prevClass = 
			   symrecord.setClass(ident, SymbolRecord.UNIT_CLASS);
                       if(prevClass != 0)
		           identClassError(ident, SymbolRecord.UNIT_CLASS, 
	 	               prevClass);
		       RESULT = new Unit(ident);
                    :}
		    ;

field		::= IDENTIFIER:ident
		    {:
		       int prevClass = 
		        symrecord.setClass(ident, SymbolRecord.VARIABLE_CLASS);
		       if(prevClass != 0)
		           identClassError(ident, SymbolRecord.VARIABLE_CLASS,
		               prevClass);
		       RESULT = new Variable(ident, symrecord);
		    :}
		    ;

line_terminator ::= PERIOD
		    {: RESULT = new Terminator(Node.IMP_TERM); :}
		    ;
