/**
 * Tree-generating parser for Quant.
 *
 * Run with CUP to generate sym.java
 * (Needed to run scanner generated by
 * JFlex + lexer.jflex.)
 * --Aubrey
 */

import java_cup.runtime.*;
import java.util.ArrayList;

action code {:
    public SymbolRecord symrecord = new SymbolRecord();
    public void identClassError(String identifier, int expected, int found){
        System.out.println("It looks like you're using '"+identifier+"'as a "+
            SymbolRecord.CLASSES[expected]+", but it's a "+
            SymbolRecord.CLASSES[found]+"!");
        System.exit(0);
    }
    public void notDefinedError(String identifier){
        System.out.println("Wait a second!  What's a '"+identifier+"'?");
        System.exit(0);
    }
    public void typeDefError(String type, String stype, int err){
        if(err == SymbolRecord.TYPE_DEFINED)
            System.out.println("Woops!  You've said what a '"+type+"' is twice!");
        else if(err == SymbolRecord.SUPERTYPE_UNDEFINED)
            System.out.println("Wait a second!  You said a '"+type+"' was a '"+stype+"'...\n"+
                               "What's a '"+stype+"'?");
        else
            System.out.println("Woops!  It looks like you haven't said what a '"+type+"' is!");
        System.exit(0);
    }
    
:}

parser code {:
:}

/*
 * Symbol definitions`
 */
terminal PRINT;
terminal A; 
terminal IS_A;
terminal IS, ARE;
terminal SET;
terminal TO, THAN, NOT; 
terminal IF, THEN, ELSE, WHILE;
terminal LESS_THAN, GREATER_THAN, EQUAL_TO, NEQUAL_TO;
terminal AND, OR;
terminal THERE; 
terminal IN;
terminal FOR;
terminal EVERY; 
terminal HAS;
terminal WITH;
terminal HAVING; 
terminal APO_S;

terminal String IDENTIFIER;
terminal String STRING_LITERAL;
terminal Integer INTEGER_LITERAL;
terminal Double RATIONAL_LITERAL;

terminal LPAREN, RPAREN;
terminal PLUS, MINUS, TIMES, DIVIDE;
terminal PERIOD, COLON, SEMICOLON;
terminal CONNECTOR;
terminal INVALID;

/*
 * non-terminals
 */
non terminal Node line_block;
non terminal Node line;
non terminal Node statement;
non terminal Node stmt_sequence;
non terminal Node optv_statement;
non terminal Node asmt_statement;
non terminal Node line_terminator;
non terminal Node operative_kwd;
non terminal Node value;
non terminal Node quantity;
non terminal Node number;
non terminal Node unit;
non terminal Node expression;
non terminal Node field;
non terminal Node cond_block;
non terminal Node if_then_else;
non terminal Node while;
non terminal Node bool_seq;
non terminal Node bool_exp;
non terminal conjunctive;
non terminal Node rate_dec; 
non terminal Node type_dec; 
non terminal Node colon; 
non terminal Node type_sig;
non terminal Node type_ref; 
non terminal Node mem_type_chain;
non terminal Node mem_type;
non terminal Node mem_ref; 
non terminal Node ident_chain;   

precedence left LESS_THAN, GREATER_THAN, EQUAL_TO, NEQUAL_TO;
precedence left AND, OR;
precedence left PLUS, MINUS;
precedence left TIMES, DIVIDE;
precedence left ELSE;

line_block	::= line_block:lb line:ln
		    {: lb.addChild(ln); RESULT = lb; :}
		    |
		    line:ln
		    {: LineBlock lb = new LineBlock(ln); 
                       lb.symrecord = symrecord;
                       RESULT = lb;
                    :}
		    ;

line		::= statement:stmt line_terminator:lt
		    {: RESULT = new Line(stmt, lt); :}
                    |
		    rate_dec:rd line_terminator:lt
	 	    {: RESULT = new Line(rd,lt); :}
		    |
                    type_dec:td line_terminator:lt
                    {: RESULT = new Line(td,lt); :}
                    |
                    cond_block:cb
		    {: RESULT = cb; :}
                    ;

rate_dec	::= THERE IS number:n unit:u IN number:n2 unit:u2
		    {: RESULT = new RateDeclaration(n,u,n2,u2); :}
		    |
		    THERE ARE number:n unit:u IN number:n2 unit:u2
		    {: RESULT = new RateDeclaration(n,u,n2,u2); :}
		    |
		    THERE IS number:n unit:u FOR EVERY number:n2 unit:u2
		    {: RESULT = new RateDeclaration(n,u,n2,u2); :}
		    |
		    THERE ARE number:n unit:u FOR EVERY number:n2 unit:u2
		    {: RESULT = new RateDeclaration(n,u,n2,u2); :}
		    ;

type_dec	::= type_sig:sig COLON mem_type_chain:mem_chain    
		    {: 
                       TypeDec dec = new TypeDec(sig, null, symrecord);
                       String type = ((TypeRef) ((TypeSignature) sig).typeRef).getType();
                       DefinedType oType = symrecord.getTypeObj(type);
                       ArrayList<Node> mTypes = ((MemTypeChain) mem_chain).memTypes;
                       for(int i = 0; i < mTypes.size(); i++){
                           MemberType mt = (MemberType) mTypes.get(i);
                           oType.setValue(mt.identifier,mt.type,mt.val);
                       }
                       RESULT = dec;
                    :}
		    |
		    type_sig:sig
		    {: RESULT = new TypeDec(sig, null, symrecord); :}
		    ;

type_sig	::= type_ref:ref HAS ident_chain:ident_chain
		    {: 
                       String type = ((TypeRef) ref).getType();
                       int err = symrecord.defineType(type,null);
                       if(err != 0)
                           typeDefError(type,null,err);
                       symrecord.addTypeFields(type,((IdentifierChain) ident_chain).getIdentifiers());
                       RESULT = new TypeSignature(ref,ident_chain,symrecord); 
                    :}
		    |
		    type_ref:ref WITH ident_chain:ident_chain
		    {: :}
		    |
		    type_ref:ref HAVING ident_chain:ident_chain
		    {: :}
		    |
                    type_ref:ref IS type_ref:ref2
                    {:
                        String nType = ((TypeRef) ref).getType();
                        String sType = ((TypeRef) ref2).getType();
                        int err = symrecord.defineType(nType,sType);
                        if(err != 0)
                           typeDefError(nType,sType,err);
                        RESULT = new TypeSignature(ref,ref2,null,symrecord);
                    :}
                    |
		    type_ref:ref IS type_ref:ref2 WITH ident_chain:ident_chain
		    {: :}
		    |
		    type_ref:ref IS type_ref:ref2 HAVING ident_chain:ident_chain
		    {: :}
		    ; 

mem_type_chain  ::= mem_type_chain:mem_type AND mem_type:mem_type1
		    {:
                       mem_type.addChild(mem_type1);
                       RESULT = mem_type; 
                    :}
		    |
		    mem_type_chain:mem_type_chain CONNECTOR mem_type:mem
		    {:
                       mem_type_chain.addChild(mem);
                       RESULT = mem_type_chain; 
                    :}
		    |
		    mem_type_chain:mem_type_chain CONNECTOR AND mem_type:mem
		    {:
                       mem_type_chain.addChild(mem);
                       RESULT = mem_type_chain; 
                    :}
		    |
		    mem_type:mem
		    {: RESULT = new MemTypeChain(mem); :}
		    ;

mem_type	::= IDENTIFIER:ident1 IS type_ref:ref
		    {:
                        String type = ((TypeRef) ref).getType();
                        if(!symrecord.typeIsDefined(type)){
                            typeDefError(ident1,null,10);
                        }
                        RESULT = new MemberType(ident1, type, "" , symrecord);
                    :}
		    |
		    IDENTIFIER:ident2 IS expression:expr
		    {:
                        if(expr.getSemanticRepresentation().equals("STRING")){
                            RESULT = new MemberType(ident2,"String", expr.translate()[1], symrecord);
                        } else{
                            String trans = expr.translate()[1];
                            if(expr.getSemanticRepresentation().equals(""))
                            	RESULT = new MemberType(ident2,"NUMVAL",trans,symrecord);
                            else{
                                String t = expr.getSemanticRepresentation();
                                RESULT = new MemberType(ident2,expr.getSemanticRepresentation(),
                                                trans,symrecord);
                            }
                        } 
                    :}
		    ;

type_ref	::= A IDENTIFIER:ident1
		    {: int i = symrecord.setClass(ident1, SymbolRecord.TYPE_CLASS); 
                       if(i != 0){ identClassError(ident1, SymbolRecord.TYPE_CLASS, i); }
                       RESULT = new TypeRef(ident1,symrecord); 
                    :}
		    ;

ident_chain  	::= IDENTIFIER:ident1
		    {: RESULT = new IdentifierChain(ident1); :}
		    |
		    ident_chain:ident2 AND IDENTIFIER:ident3
		    {: ((IdentifierChain) ident2).addIdentifier(ident3); 
                       RESULT = ident2;
                    :}
		    |
		    ident_chain:ident4 CONNECTOR IDENTIFIER:ident5
		    {: ((IdentifierChain) ident4).addIdentifier(ident5); 
                       RESULT = ident4;
                    :} 
		    |
		    ident_chain:ident6 CONNECTOR AND IDENTIFIER:ident7 
		    {: ((IdentifierChain) ident6).addIdentifier(ident7); 
                       RESULT = ident6;
                    :}
		    ;


statement	::= optv_statement:ostmt
		    {: RESULT = new Statement(ostmt); :}
		    |
		    asmt_statement:astmt
		    {: RESULT = new Statement(astmt); :}
		    ;

stmt_sequence	::= statement:s
		    {: RESULT = new StatementSequence(s); :}
		    |
		    cond_block:cb
		    {: RESULT = new StatementSequence(cb); :}
		    |
		    stmt_sequence:seq CONNECTOR statement:stmt
		    {: seq.addChild(stmt);
		       RESULT = seq;
		    :}
		    |
		    stmt_sequence:seq CONNECTOR AND statement:stmt
		    {: seq.addChild(stmt);
		       RESULT = seq;
		    :}
		    |
		    cond_block:cb statement:s
		    {: StatementSequence seq = new StatementSequence(cb);
		       seq.addChild(s);
		       RESULT = seq;
		    :}
		    |
		    cond_block:cb cond_block:cb2
		    {: StatementSequence seq = new StatementSequence(cb);
		       seq.addChild(cb2);
		       RESULT = seq;
		    :}
		    |

		    stmt_sequence:seq AND statement:stmt
		    {: seq.addChild(stmt);
		       RESULT = seq;
		    :}

		    ;

cond_block	::= if_then_else:i
		    {: RESULT = i; :}
		    |
		    while:w
		    {: RESULT = w; :}
		    ;

if_then_else	::= IF bool_seq:cond CONNECTOR THEN stmt_sequence:t_seq 
		        conjunctive
		    {: RESULT = new IfElseBlock(cond,t_seq,null); :}
		    |
		    IF bool_seq:cond CONNECTOR THEN stmt_sequence:t_seq
		        conjunctive ELSE CONNECTOR stmt_sequence:f_seq 
		            conjunctive
		    {: RESULT = new IfElseBlock(cond,t_seq,f_seq); :}
		    |
		    
                    IF bool_seq:cond CONNECTOR stmt_sequence:t_seq conjunctive
		    {: RESULT = new IfElseBlock(cond,t_seq,null); :}
		    |
		    IF bool_seq:cond CONNECTOR stmt_sequence:t_seq
		        conjunctive ELSE CONNECTOR stmt_sequence:f_seq 
		            conjunctive
		    {: RESULT = new IfElseBlock(cond,t_seq,f_seq); :}

		    ;

conjunctive	::= SEMICOLON
		    |
		    PERIOD
		    ;

while		::= WHILE bool_seq:cond CONNECTOR stmt_sequence:t_seq PERIOD
		    {: RESULT = new WhileBlock(cond, t_seq); :}
		    ;

bool_seq	::= bool_exp:exp
		    {:  System.out.println("bool seq found");
                        RESULT = new BooleanSequence(exp,null,-1); 
                    :}
		    |
		    bool_seq:l AND bool_seq:r
		    {: RESULT = new BooleanSequence(l,r,Node.SEM_AND);
		    :}
		    |
		    bool_seq:l OR bool_seq:r
		    {: RESULT = new BooleanSequence(l,r,Node.SEM_OR);
		    :}
		    |
		    LPAREN bool_seq:s RPAREN
		    {: RESULT = s; :}
		    ;

bool_exp	::= expression:l LESS_THAN expression:r
		    {: RESULT = new BooleanExpression(l,r, Node.SEM_LESS_THAN);
                       System.out.println("boolexp found");
		    :}
		    |
		    expression:l GREATER_THAN expression:r
		    {: RESULT = new BooleanExpression(l,r, 
                           Node.SEM_GREATER_THAN);
		    :}
		    |
		    expression:l EQUAL_TO expression:r
		    {: RESULT = new BooleanExpression(l,r,
		           Node.SEM_EQUAL_TO);
		    :}
		    |
		    expression:l IS expression:r
		    {: RESULT = new BooleanExpression(l,r,
		           Node.SEM_EQUAL_TO);
		    :}
		    |

		    expression:l NEQUAL_TO expression:r
		    {: RESULT = new BooleanExpression(l,r,
		           Node.SEM_NEQUAL_TO);
		    :}
		    |
                    expression:l IS LESS_THAN THAN expression:r
		    {: RESULT = new BooleanExpression(l,r, Node.SEM_LESS_THAN);
                       System.out.println("boolexp found");
		    :}
		    |
		    expression:l IS GREATER_THAN THAN expression:r
		    {: RESULT = new BooleanExpression(l,r, 
                           Node.SEM_GREATER_THAN);
		    :}
		    |
		    expression:l IS EQUAL_TO TO expression:r
		    {: RESULT = new BooleanExpression(l,r,
		           Node.SEM_EQUAL_TO);
		    :}
		    |
		    expression:l IS NOT EQUAL_TO TO expression:r
		    {: RESULT = new BooleanExpression(l,r,
		           Node.SEM_NEQUAL_TO);
		    :}

	            ;

asmt_statement	::= field:f IS expression:v
		    {: 
		       if(v.getSemanticRepresentation().equals("STRING"))
		           ((Variable) f).setType(SymbolRecord.STRING_TYPE);
		       else
		           ((Variable) f).setType(SymbolRecord.QUANTITY_TYPE);
		       RESULT = new AssignmentStatement(f,v,
		                        Node.ASSMNT_MODE);
		    :}
		    |
		    SET field:f TO expression:v
		    {: if(v.getSemanticRepresentation().equals("STRING"))
		           ((Variable) f).setType(SymbolRecord.STRING_TYPE);
		       else
		           ((Variable) f).setType(SymbolRecord.QUANTITY_TYPE);
		       RESULT = new AssignmentStatement(f,v,
		                        Node.ASSMNT_MODE);
		    :}
                    |
                    field:f IS A type_ref:ref
		    {: :}	
		    ;

optv_statement	::= operative_kwd:kwd expression:e
		    {: RESULT = new OperativeStatement(kwd, e); :}
		    ;

operative_kwd	::= PRINT
		    {: RESULT = new OperativeKeyword(Node.SEM_PRINT_KWD); :}
		    ;

expression	::= expression:l PLUS expression:r
		    {: RESULT = new Expression(l,r, Node.SEM_PLUS); :}
		    |
		    expression:l MINUS expression:r
		    {: RESULT = new Expression(l,r, Node.SEM_MINUS); :}
    		    |
		    expression:l TIMES expression:r
		    {: RESULT = new Expression(l,r, Node.SEM_TIMES); :}
		    |
		    expression:l DIVIDE expression:r
		    {: RESULT = new Expression(l,r, Node.SEM_DIVIDE); :}
		    |
		    value:v
		    {: RESULT = v; :}
		    |
		    LPAREN expression:v RPAREN
		    {: RESULT = v; :}
                    ;

value		::= STRING_LITERAL:s
		    {: RESULT = new StringConstant(s); :}
		    |
		    quantity:q
		    {: RESULT = new Value(q); :}
		    |
		    field:f
		    {: if(symrecord.getType(((Variable) f).getName())==null)
		           notDefinedError(((Variable) f).getName());
		       RESULT = f;
		    :}
		    ;

quantity	::= number:num unit:u
		    {: System.out.println("quantity"); RESULT = new Quantity(num, u); :}
                    |
		    number:num
		    {: RESULT = new Quantity(num, null); :}
		    ;

number		::= INTEGER_LITERAL:num
		    {: RESULT = new Number(num); :}
		    |
		    RATIONAL_LITERAL:num
		    {: RESULT = new Number(num); :}
		    ;

unit		::= IDENTIFIER:ident
		    {: 
                       int prevClass = 
			   symrecord.setClass(ident, SymbolRecord.UNIT_CLASS);
                       if(prevClass != 0)
		           identClassError(ident, SymbolRecord.UNIT_CLASS, 
	 	               prevClass);
		       RESULT = new Unit(ident);
                    :}
		    ;

field		::= IDENTIFIER:ident
		    {:
		       int prevClass = 
		        symrecord.setClass(ident, SymbolRecord.VARIABLE_CLASS);
		       if(prevClass != 0)
		           identClassError(ident, SymbolRecord.VARIABLE_CLASS,
		               prevClass);
		       RESULT = new Variable(ident, symrecord);
		    :}
		    |
                    mem_ref:mem
		    {: :}
		    ;

mem_ref		::= IDENTIFIER:ident1 APO_S IDENTIFIER:ident2
		    {: :}
		    ;

line_terminator ::= PERIOD
		    {: RESULT = new Terminator(Node.IMP_TERM); :}
		    ;
